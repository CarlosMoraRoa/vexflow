/**
 * Document - generic interface for parsing and displaying a document
 * @author Daniel Ringwalt (ringw)
 */

if (! Vex.Flow.Backend) Vex.Flow.Backend = {};

/**
 * Vex.Flow.Backend.IR - return measures from intermediate JSON representation
 * @constructor
 */
Vex.Flow.Backend.IR = function() {
  this.documentObject = null;
}

/**
 * "Parse" an existing IR document object (not necessarily an instance of Document).
 *
 * @param object The original document object
 */
Vex.Flow.Backend.IR.prototype.parse = function(object) {
  if (! Vex.Flow.Backend.IR.appearsValid(object))
    throw new Vex.RERR("InvalidArgument", "IR object must be a valid document");
  
  this.documentObject = object;
  this.valid = true;
}

Vex.Flow.Backend.IR.prototype.isValid = function() { return this.valid; }

/**
 * Class method.
 * Returns true if the argument appears to a valid document object.
 * Used when automatically detecting VexFlow IR.
 *
 * @return {Boolean} True if object looks like a valid document.
 */
Vex.Flow.Backend.IR.appearsValid = function(object) {
  return typeof object == "object" && object.type == "document";
}

/**
 * Number of measures in the document
 *
 * @return {Number} Total number of measures
 */
Vex.Flow.Backend.IR.prototype.getNumberOfMeasures = function() {
  return this.documentObject.measures.length;
}

/**
 * Create the ith measure from this.measures[i]
 *
 * @return {Vex.Flow.Measure} ith measure as a Measure object
 */
Vex.Flow.Backend.IR.prototype.getMeasure = function(i) {
  return new Vex.Flow.Measure(this.documentObject.measures[i]);
}

/**
 * Vex.Flow.Document - generic container of measures generated by a backend
 * @constructor
 */
Vex.Flow.Document = function(data, options) {
  if (arguments.length > 0) this.init(data, options);
}

Vex.Flow.Document.backends = [Vex.Flow.Backend.IR, Vex.Flow.Backend.MusicXML];
if (Vex.Flow.Backend.VexTab)
  Vex.Flow.Documents.backends.push(Vex.Flow.Backend.VexTab);

Vex.Flow.Document.prototype.init = function(data, options) {
  this.options = {};
  Vex.Merge(this.options, options);
  this.measures = new Array();
  if (! data) {
    this.backend = null;
    return;
  }
  var backends = (typeof this.options.backend == "function")
                 ? [this.options.backend] : Vex.Flow.Document.backends;
  for (var i = 0; i < backends.length; i++) {
    var Backend = backends[i];
    if (Backend.appearsValid(data)) {
      this.backend = new Backend();
      this.backend.parse(data);
      if (! this.backend.isValid())
        throw new Vex.RERR("ParseError", "Could not parse document data");
    }
  }
  if (! this.backend)
    throw new Vex.RERR("ParseError", "Data in document appears to be unsupported");
}

/**
 * Number of measures in the document
 * @return {Number} Total number of measures
 */
Vex.Flow.Document.prototype.getNumberOfMeasures = function() {
  return this.backend.getNumberOfMeasures();
}

/**
 * Retrieve the ith measure (zero-indexed).
 * @param {Number} The zero-indexed measure to access.
 * @return {Vex.Flow.Measure} Measure object corresponding to the measure number.
 */
Vex.Flow.Document.prototype.getMeasure = function(i) {
  if (i in this.measures) return this.measures[i];
  var measure = this.backend.getMeasure(i);
  this.measures[i] = measure;
  return measure;
}

/**
 * Draw the complete document in the rect given by x, y, width, height with context.
 * @param {Object} Options (x, y, width, height, context required)
 */
Vex.Flow.Document.prototype.draw = function(options) {
  // TODO: Multiple measure/stave support
  var measure = this.getMeasure(0);
  var part = measure.getPart(0);
  var stave = part.getStave(0);
  // Force create stave with the correct x, y, width
  //var vfStave = stave.getVexflowStave(options.x+10, options.y, options.width-20);
  this.layoutMeasure(measure, options.x+10, options.y, options.width-20);
  //part.draw(options.context);
  this.drawPart(part, options.context);
}

/**
 * Lay out staves in the measure, starting from (x, y).
 * Return coordinates {x, y, width, height} of the entire measure.
 */
Vex.Flow.Document.prototype.layoutMeasure = function(measure, x, y, width) {
  // Join staves from all parts in one array
  var staves = new Array();
  var numParts = measure.getNumberOfParts();
  for (var i = 0; i < numParts; i++) {
    var part = measure.getPart(i);
    var numStaves = part.getNumberOfStaves();
    for (var j = 0; j < numStaves; j++) staves.push(part.getStave(j));
  }

  // Lay out each stave
  var origY = y;
  for (var i = 0; i < staves.length; i++) {
    staves[i].setX(x);
    staves[i].setY(y);
    staves[i].setWidth(width);
    y += staves[i].getHeight();
  }
  return {x: x, y: origY, width: width, height: y - origY};
}

/**
 * Draw staves and voices of a part. (The measure must be laid out first.)
 */
Vex.Flow.Document.prototype.drawPart = function(part, context) {
  var staves = new Array(part.getNumberOfStaves());
  for (var i = 0; i < part.getNumberOfStaves(); i++) staves[i] = part.getStave(i);
  var voices = new Array(part.getNumberOfVoices());
  for (var i = 0; i < part.getNumberOfVoices(); i++) voices[i] = part.getVoice(i);

  // Array for each stave -> array of voices corresponding to that stave
  var voicesForStave = new Array(part.getNumberOfStaves());
  if (staves.length == 1) {
    for (var i = 0; i < voices.length; i++) voices[i].stave = 0;
    voicesForStave[0] = voices;
  }
  else {
    for (var i = 0; i < voices.length; i++) {
      if (typeof voices[i].stave != "number")
        throw new Vex.RERR("InvalidIRError",
                           "Voice in multi-stave part requires stave property");
      if (voices[i].stave in voicesForStave)
        voicesForStave[voices[i].stave].push(voices[i]);
      else
        voicesForStave[voices[i].stave] = [voices[i]];
    }
  }
  for (var i = 0; i < staves.length; i++)
    staves[i].getVexflowStave().setContext(context).draw();
  for (var i = 0; i < staves.length; i++)
    if (voicesForStave[i] instanceof Array) {
      var vfVoices = new Array();
      for (var j = 0; j < voicesForStave[i].length; j++)
        vfVoices[j] = voicesForStave[i][j].getVexflowVoice();
      var formatter = new Vex.Flow.Formatter().joinVoices(vfVoices);
      var vfStave = staves[i].getVexflowStave();
      formatter.format(vfVoices, vfStave.getNoteEndX() - vfStave.getNoteStartX());
      for (var j = 0; j < vfVoices.length; j++) {
        vfVoices[j].draw(context, vfStave);
        var vfObjects = voicesForStave[i][j].getVexflowObjects();
        for (var obj = 0; obj < vfObjects.length; obj++)
          vfObjects[obj].setContext(context).draw();
      }
    }
}
