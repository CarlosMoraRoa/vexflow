/**
 * Document - generic interface for parsing and displaying a document
 * @author Daniel Ringwalt (ringw)
 */

if (! Vex.Flow.Backend) Vex.Flow.Backend = {};

/**
 * Vex.Flow.Backend.IR - return measures from intermediate JSON representation
 * @constructor
 */
Vex.Flow.Backend.IR = function() {
  this.documentObject = null;
}

/**
 * "Parse" an existing IR document object (not necessarily a Document instance)
 * @param object The original document object
 */
Vex.Flow.Backend.IR.prototype.parse = function(object) {
  if (! Vex.Flow.Backend.IR.appearsValid(object))
    throw new Vex.RERR("InvalidArgument",
                       "IR object must be a valid document");
  
  // Force a first-class document object to get all measures
  if (typeof object.getNumberOfMeasures == "function"
      && typeof object.getMeasure == "function") {
    var numMeasures = object.getNumberOfMeasures();
    for (var i = 0; i < numMeasures; i++) object.getMeasure(i);
  }
  this.documentObject = object;
  this.valid = true;
}

Vex.Flow.Backend.IR.prototype.isValid = function() { return this.valid; }

/**
 * Class method.
 * Returns true if the argument appears to a valid document object.
 * Used when automatically detecting VexFlow IR.
 *
 * @return {Boolean} True if object looks like a valid document.
 */
Vex.Flow.Backend.IR.appearsValid = function(object) {
  return typeof object == "object" && object.type == "document";
}

/**
 * Number of measures in the document
 *
 * @return {Number} Total number of measures
 */
Vex.Flow.Backend.IR.prototype.getNumberOfMeasures = function() {
  return this.documentObject.measures.length;
}

/**
 * Create the ith measure from this.measures[i]
 *
 * @return {Vex.Flow.Measure} ith measure as a Measure object
 */
Vex.Flow.Backend.IR.prototype.getMeasure = function(i) {
  return new Vex.Flow.Measure(this.documentObject.measures[i]);
}

/**
 * Vex.Flow.Document - generic container of measures generated by a backend
 * @constructor
 */
Vex.Flow.Document = function(data, options) {
  if (arguments.length > 0) this.init(data, options);
}

Vex.Flow.Document.backends = [Vex.Flow.Backend.IR, Vex.Flow.Backend.MusicXML];

Vex.Flow.Document.prototype.init = function(data, options) {
  this.options = {};
  Vex.Merge(this.options, options);
  this.measures = new Array();
  if (! data) {
    this.backend = null;
    return;
  }

  // Optionally pass constructor function for backend
  var backends = (typeof this.options.backend == "function")
                 ? [this.options.backend] : Vex.Flow.Document.backends;
  for (var i = 0; i < backends.length; i++) {
    var Backend = backends[i];
    if (Backend.appearsValid(data)) {
      this.backend = new Backend();
      this.backend.parse(data);
      if (! this.backend.isValid())
        throw new Vex.RERR("ParseError", "Could not parse document data");
    }
  }
  if (! this.backend)
    throw new Vex.RERR("ParseError", "Data in document is not supported");

  this.type = "document";
}

/**
 * Create a formatter with a copy of the document
 * (formatter may add clefs, etc. when formatting document)
 * @param {Function} Class of formatter
 * @return {Vex.Flow.Document.Formatter} Document formatter with document copy
 */
Vex.Flow.Document.prototype.getFormatter = function(formatterClass) {
  var Formatter = formatterClass;
  if (typeof FormatterClass != "function")
    Formatter = Vex.Flow.Document.LiquidFormatter; // default class
  return new Formatter(new Vex.Flow.Document(this));
}

/**
 * Number of measures in the document
 * @return {Number} Total number of measures
 */
Vex.Flow.Document.prototype.getNumberOfMeasures = function() {
  return this.backend.getNumberOfMeasures();
}

/**
 * Retrieve the ith measure (zero-indexed).
 * @param {Number} The zero-indexed measure to access.
 * @return {Vex.Flow.Measure} Measure object for corresponding measure
 */
Vex.Flow.Document.prototype.getMeasure = function(i) {
  if (i in this.measures) return this.measures[i];
  var measure = this.backend.getMeasure(i);
  this.measures[i] = measure;
  return measure;
}

/**
 * Vex.Flow.Document.Formatter - abstract base class for formatters
 * Accepts document as argument and draws document in discrete chunks
 *
 * @param {Vex.Flow.Document} Document object to retrieve information from
 * @constructor
 */
Vex.Flow.Document.Formatter = function(document) {
  if (arguments.length > 0) this.init(document);
}

Vex.Flow.Document.Formatter.prototype.init = function(document) {
  if (typeof document != "object")
    throw new Vex.RERR("ArgumentError",
      "new Vex.Flow.Document.Formatter() requires Document object argument");
  this.document = document;

  // Groups of measures are contained in blocks (which could correspond to a
  // line or a page of music.)
  // Each block is intended to be drawn on a different canvas.
  // Blocks must be managed by the subclass.
  this.measuresInBlock = []; // block # -> array of measure # in block
  this.blockDimensions = []; // block # -> [width, height]

  // Store VexFlow staves, voices, objects. Stave layout managed by subclass
  this.vfStaves = []; // measure # -> stave # -> VexFlow stave
  this.vfVoices = []; // measure # -> voice # -> VexFlow voice
  this.vfObjects = []; // measure # -> corresponding voice # -> all objects
  this.staveForVoice = []; // measure # -> array of stave # for each voice

  // Minimum measure widths can be used for formatting by subclasses
  this.minMeasureWidths = [];
}

/**
 * Vex.Flow.Document.Formatter.prototype.getStaveX: to be defined by subclass
 * Params: m (measure #), s (stave #)
 * Returns: x (number)
 */

/**
 * Calculate vertical position of stave within block
 * @param {Number} Measure number
 * @param {Number} Stave number
 */
Vex.Flow.Document.Formatter.prototype.getStaveY = function(m, s) {
  // Default behavour: calculate from stave above this one (or 0 for top stave)
  // (Have to make sure not to call getStave on this stave)
  if (s == 0) return 0;

  var higherStave = this.getStave(m, s - 1);
  return higherStave.y + higherStave.getHeight();
}

/**
 * Vex.Flow.Document.Formatter.prototype.getStaveWidth: defined in subclass
 * Params: m (measure #), s (stave #)
 * Returns: width (number) which should be less than the minimum width
 */

/**
 * Create a Vex.Flow.Stave from a Vex.Flow.Measure.Stave.
 * @param {Vex.Flow.Measure.Stave} Original stave object
 * @param {Number} x position
 * @param {Number} y position
 * @param {Number} width of stave
 * @return {Vex.Flow.Stave} Generated stave object
 */
Vex.Flow.Document.Formatter.prototype.createVexflowStave = function(s, x,y,w) {
  var vfStave = new Vex.Flow.Stave(x, y, w);
  s.modifiers.forEach(function(mod) {
    switch (mod.type) {
      case "clef": vfStave.addClef(mod.clef); break;
      case "key": vfStave.addKeySignature(mod.key); break;
      case "time":
        var time_sig;
        if (typeof mod.time == "string") time_sig = mod.time;
        else time_sig = mod.num_beats.toString() + "/"
                      + mod.beat_value.toString();
        vfStave.addTimeSignature(time_sig);
        break;
    }
  });
  return vfStave;
}

/**
 * Use getStaveX, getStaveY, getStaveWidth to create a Vex.Flow.Stave from
 * the document and store it in vfStaves.
 * @param {Number} Measure number
 * @param {Number} Stave number
 * @return {Vex.Flow.Stave} Stave for the measure and stave #
 */
Vex.Flow.Document.Formatter.prototype.getStave = function(m, s) {
  if (m in this.vfStaves && s in this.vfStaves[m])
    return this.vfStaves[m][s];
  if (typeof this.getStaveX != "function"
      || typeof this.getStaveWidth != "function")
    throw new Vex.RERR("MethodNotImplemented",
                "Document formatter must implement getStaveX, getStaveWidth");
  var stave = this.document.getMeasure(m).getStave(s);
  if (! stave) return undefined;
  var vfStave = this.createVexflowStave(stave,
                                        this.getStaveX(m, s),
                                        this.getStaveY(m, s),
                                        this.getStaveWidth(m, s));
  if (! (m in this.vfStaves)) this.vfStaves[m] = [];
  this.vfStaves[m][s] = vfStave;
  return vfStave;
}

/**
 * Get the array of all Vex.Flow.Voices for the measure, populating
 * vfVoices, vfObjects, and staveForVoice if necessary.
 * @param {Number} Measure number
 * @return {Array} Array of Vex.Flow.Voices
 */
Vex.Flow.Document.Formatter.prototype.getVoices = function(m) {
  if (m in this.vfVoices) return this.vfVoices[m];
  var allVfVoices = [], allVfObjects = [], allStavesForVoices = [];
  var measure = this.document.getMeasure(m);
  var numParts = measure.getNumberOfParts();
  var partFirstStave = 0; // First stave in this part
  for (var i = 0; i < numParts; i++) {
    var part = measure.getPart(i);
    var partStaves = [];
    for (var s = 0; s < part.getNumberOfStaves(); s++)
      partStaves[s] = part.getStave(s);
    var numVoices = part.getNumberOfVoices();
    for (var j = 0; j < numVoices; j++) {
      var voice = part.getVoice(j);
      if (typeof voice.stave != "number")
        throw new Vex.RERR("InvalidIRError", "Voice must have stave property");
      allVfVoices.push(voice.getVexflowVoice(partStaves));
      allVfObjects.push(voice.getVexflowObjects(partStaves));
      allStavesForVoices.push(voice.stave + partFirstStave);
    }
    partFirstStave += partStaves.length;
  }
  this.vfVoices[m] = allVfVoices;
  this.vfObjects[m] = allVfObjects;
  this.staveForVoice[m] = allStavesForVoices;
  return allVfVoices;
}

Vex.Flow.Document.Formatter.prototype.getMinMeasureWidth = function(m) {
  if (! this.minMeasureWidths || ! (m in this.minMeasureWidths)) {
    var formatter = new Vex.Flow.Formatter();
    var minWidth = formatter.preCalculateMinTotalWidth(this.getVoices(m));

    // Calculate the maximum extra width on any stave (due to modifiers)
    var maxExtraWidth = 0;
    var measure = this.document.getMeasure(m);
    var numParts = measure.getNumberOfParts();
    for (var i = 0; i < numParts; i++) {
      var part = measure.getPart(i);
      var numStaves = part.getNumberOfStaves();
      for (var j = 0; j < numStaves; j++) {
        var stave = part.getStave(j);
        var vfStave = this.createVexflowStave(stave, 0, 0, 500);
        var extraWidth = 500 - (vfStave.getNoteEndX()-vfStave.getNoteStartX());
        if (extraWidth > maxExtraWidth) maxExtraWidth = extraWidth;
      }
    }
    minWidth += maxExtraWidth;
    this.minMeasureWidths[m] = minWidth;
  }
  return this.minMeasureWidths[m];
};

// Internal drawing functions
(function(){
  // drawConnector: 0 = none, 1 = single at start, 2 = single at end,
  //                4 = single connecting all parts (applies to drawMeasure),
  //                8 = brace (with bitwise OR)
  function drawPart(part, vfStaves, context, drawConnector) {
    var staves = new Array(part.getNumberOfStaves());
    for (var i = 0; i < part.getNumberOfStaves(); i++)
      staves[i] = part.getStave(i);

    var voices = new Array(part.getNumberOfVoices());
    for (var i = 0; i < part.getNumberOfVoices(); i++)
      voices[i] = part.getVoice(i);

    // Array for each stave -> array of voices corresponding to that stave
    // TODO: Set stave for each voice, then format all voices together
    var voicesForStave = new Array(part.getNumberOfStaves());
    if (staves.length == 1) {
      for (var i = 0; i < voices.length; i++) voices[i].stave = 0;
      voicesForStave[0] = voices;
    }
    else
      voices.forEach(function(voice) {
        if (typeof voice.stave != "number")
          throw new Vex.RERR("InvalidIRError",
                             "Voice in multi-stave part needs stave property");
        if (voice.stave in voicesForStave)
          voicesForStave[voice.stave].push(voice);
        else
          voicesForStave[voice.stave] = [voice];
      });
    vfStaves.forEach(function(stave) { stave.setContext(context).draw(); });

    // Draw connectors for multiple staves
    if (vfStaves.length > 1) {
      if (drawConnector & 1)
        (new Vex.Flow.StaveConnector(vfStaves[0], vfStaves[vfStaves.length-1]))
          .setType(Vex.Flow.StaveConnector.type.SINGLE)
          .setContext(context).draw();
      if (drawConnector & 2) {
        // Create dummy staves which start after these staves
        var stave1 = vfStaves[0], stave2 = vfStaves[vfStaves.length - 1];
        var dummy1 = new Vex.Flow.Stave(stave1.x + stave1.width,
                                        stave1.y, 100);
        var dummy2 = new Vex.Flow.Stave(stave2.x + stave2.width,
                                        stave2.y, 100);
        (new Vex.Flow.StaveConnector(dummy1, dummy2))
          .setType(Vex.Flow.StaveConnector.type.SINGLE)
          .setContext(context).draw();
      }
      if ((drawConnector & 8) && part.showsBrace())
        (new Vex.Flow.StaveConnector(vfStaves[0], vfStaves[vfStaves.length-1]))
          .setType(Vex.Flow.StaveConnector.type.BRACE)
          .setContext(context).draw();
    }

    for (var i = 0; i < staves.length; i++)
      if (voicesForStave[i] instanceof Array) {
        var vfVoices = new Array();
        for (var j = 0; j < voicesForStave[i].length; j++)
          vfVoices[j] = voicesForStave[i][j].getVexflowVoice(staves);
        var formatter = new Vex.Flow.Formatter().joinVoices(vfVoices);
        formatter.format(vfVoices, vfStaves[i].getNoteEndX()
                                   - vfStaves[i].getNoteStartX());
        for (var j = 0; j < vfVoices.length; j++) {
          vfVoices[j].draw(context, vfStaves[i]);
          var vfObjects = voicesForStave[i][j].getVexflowObjects();
          for (var obj = 0; obj < vfObjects.length; obj++)
            vfObjects[obj].setContext(context).draw();
        }
      }
  }

  function drawMeasure(measure, vfStaves, context, drawConnector) {
    var startStave = 0;
    measure.getParts().forEach(function(part) {
      var numStaves = part.getNumberOfStaves();
      var partStaves = vfStaves.slice(startStave, startStave + numStaves);
      drawPart(part, partStaves, context, drawConnector);
      startStave += numStaves;
    });
    if (vfStaves.length > 1 && (drawConnector & 4)) {
      var connector = new Vex.Flow.StaveConnector(vfStaves[0],
                                                  vfStaves[vfStaves.length-1]);
      connector.setType(Vex.Flow.StaveConnector.type.SINGLE);
      connector.setContext(context).draw();
    }
  }
  
  Vex.Flow.Document.Formatter.prototype.drawBlock = function(b, context) {
    this.getBlock(b);
    var that = this;
    var measures = this.measuresInBlock[b];
    measures.forEach(function(m) {
      var stave = 0;
      while (that.getStave(m, stave)) stave++;
      drawMeasure(that.document.getMeasure(m), that.vfStaves[m], context,
                  // Always connect start of individial stave
                  // Connect end if this is the last measure
                  1 | (2*Number(b == measures[measures.length - 1]))
                  // Connect all measures (4) and draw braces (8)
                  // if this is the first measure
                  | (12*Number(b == measures[0])));
    });
  }
})();

/**
 * Vex.Flow.Document.Formatter.prototype.draw - defined in subclass
 * Render document inside HTML element, creating canvases, etc.
 * Called a second time to update as necessary if the width of the element
 * changes, etc.
 * @param {Node} HTML node to draw inside
 * @param {Object} Subclass-specific options
 */

/**
 * Vex.Flow.Document.LiquidFormatter - default liquid formatter
 * Fit measures onto lines with a given width, in blocks of 1 line of music
 *
 * @constructor
 */
Vex.Flow.Document.LiquidFormatter = function(document) {
  if (arguments.length > 0) Vex.Flow.Document.Formatter.call(this, document);
  this.width = 500; // default value
}
Vex.Flow.Document.LiquidFormatter.prototype
  = new Vex.Flow.Document.Formatter();
Vex.Flow.Document.LiquidFormatter.constructor
  = Vex.Flow.Document.LiquidFormatter;

Vex.Flow.Document.LiquidFormatter.prototype.setWidth = function(width) {
  this.width = width; return this; }

Vex.Flow.Document.LiquidFormatter.prototype.getBlock = function(b) {
  if (b in this.blockDimensions) return this.blockDimensions[b];

  var startMeasure = 0;
  if (b > 0) {
    this.getBlock(b - 1);
    var prevMeasures = this.measuresInBlock[b - 1];
    startMeasure = prevMeasures[prevMeasures.length - 1] + 1;
  }
  var numMeasures = this.document.getNumberOfMeasures();
  if (startMeasure >= numMeasures) return null;

  // Update modifiers for first measure
  this.document.getMeasure(startMeasure).getParts().forEach(function(part) {
    part.getStaves().forEach(function(s) {
      if (typeof s.clef == "string" && ! s.getModifier("clef")) {
        s.addModifier({type: "clef", clef: s.clef});
      }
      if (typeof s.key == "string" && ! s.getModifier("key")) {
        s.addModifier({type: "key", key: s.key});
      }
      // Time signature on first measure of piece only
      if (startMeasure == 0 && ! s.getModifier("time")) {
        if (typeof s.time_signature == "string")
          s.addModifier({type: "time", time: s.time_signature});
        else if (typeof s.time == "object")
          s.addModifier(Vex.Merge({type: "time"}, s.time));
      }
    });
  });
  
  // Store x, width of staves (y calculated automatically)
  if (! this.measureX) this.measureX = new Array();
  if (! this.measureWidth) this.measureWidth = new Array();

  // Calculate start x (20 if there are braces, 10 otherwise)
  var start_x = 10;
  this.document.getMeasure(startMeasure).getParts().forEach(function(part) {
    if (part.showsBrace()) start_x = 20;
  });

  if (this.getMinMeasureWidth(startMeasure) + start_x + 10 >= this.width) {
    // Use only this measure and the minimum possible width
    var block = [this.getMinMeasureWidth(startMeasure) + start_x + 10, 0];
    this.blockDimensions[b] = block;
    this.measuresInBlock[b] = [startMeasure];
    this.measureX[startMeasure] = start_x;
    this.measureWidth[startMeasure] = block.width - start_x - 10;
  }
  else {
    var curMeasure = startMeasure;
    var width = start_x + 10;
    while (width < this.width && curMeasure < numMeasures) {
      width += this.getMinMeasureWidth(curMeasure);
      curMeasure++;
    }
    var endMeasure = curMeasure - 1;
    var measureRange = [];
    for (var m = startMeasure; m <= endMeasure; m++) measureRange.push(m);
    this.measuresInBlock[b] = measureRange;

    // Allocate width to measures
    var remainingWidth = this.width - start_x - 10;
    for (var m = startMeasure; m <= endMeasure; m++) {
      // Set each width to the minimum
      this.measureWidth[m] = Math.ceil(this.getMinMeasureWidth(m));
      remainingWidth -= this.measureWidth[m];
    }
    // Split rest of width evenly
    var extraWidth = Math.floor(remainingWidth / (endMeasure-startMeasure+1));
    for (var m = startMeasure; m <= endMeasure; m++)
      this.measureWidth[m] += extraWidth;
    remainingWidth -= extraWidth * (endMeasure - startMeasure + 1);
    this.measureWidth[startMeasure] += remainingWidth; // Add remainder
    // Calculate x value for each measure
    this.measureX[startMeasure] = start_x;
    for (var m = startMeasure + 1; m <= endMeasure; m++)
      this.measureX[m] = this.measureX[m-1] + this.measureWidth[m-1];
    this.blockDimensions[b] = [this.width, 0];
  }

  // Calculate height of first measure, use as total height
  var i = 0;
  var lastStave = undefined;
  var stave = this.getStave(startMeasure, 0);
  while (stave) {
    lastStave = stave;
    i++;
    stave = this.getStave(startMeasure, i);
  }
  var height = this.getStaveY(startMeasure, i-1) + lastStave.getHeight();
  this.blockDimensions[b][1] = height;

  return this.blockDimensions[b];
}

Vex.Flow.Document.LiquidFormatter.prototype.getStaveX = function(m, s) {
  if (! (m in this.measureX))
    throw new Vex.RERR("FormattingError",
                "Creating stave for measure which does not belong to a block");
  return this.measureX[m];
}

Vex.Flow.Document.LiquidFormatter.prototype.getStaveWidth = function(m, s) {
  if (! (m in this.measureWidth))
    throw new Vex.RERR("FormattingError",
                "Creating stave for measure which does not belong to a block");
  return this.measureWidth[m];
}

Vex.Flow.Document.LiquidFormatter.prototype.draw = function(elem, options) {
  if (this._htmlElem != elem) {
    this._htmlElem = elem;
    elem.innerHTML = "";
    this.canvases = [];
  }
  var width = $(elem).width(); // TODO: can we use jQuery?
  if (typeof width == "number") {
    if (width != this.width) {
      // Invalidate all blocks/staves/voices
      this.measuresInBlock = [];
      this.blockDimensions = [];
      this.vfStaves = [];
      this.vfVoices = [];
      this.vfObjects = [];
      this.staveForVoice = [];
      this.measureX = [];
      this.measureWidth = [];
    }
    this.setWidth(width);
  }
  var b = 0;
  while (this.getBlock(b)) {
    var canvas, context;
    if (! this.canvases[b]) {
      canvas = document.createElement('canvas');
      canvas.width = this.blockDimensions[b][0];
      canvas.height = this.blockDimensions[b][1];
      if (typeof elem.id == "string")
        canvas.id = elem.id + "_canvas" + b.toString();
      // If a canvas exists after this one, insert before that canvas
      for (var a = b + 1; this.getBlock(a); a++)
        if (typeof this.canvases[a] == "object") {
          elem.insertBefore(canvas, this.canvases[a]);
          break;
        }
      if (! canvas.parentNode)
        elem.appendChild(canvas); // Insert at the end of elem
      this.canvases[b] = canvas;
      context = canvas.getContext("2d");
    }
    else {
      canvas = this.canvases[b];
      canvas.width = this.width;
      var context = canvas.getContext("2d");
      context.clearRect(0, 0, canvas.width, canvas.height);
    }
    this.drawBlock(b, context);
    b++;
  }
  // TODO: remove old canvases/other elements
}
