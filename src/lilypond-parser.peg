start
  = space* header space* (version space*)?
    voices:(keyword space* "=" space* voice space*)+ score:score space*
    { var v = {};
      voices.forEach(function(voice) { v[voice[0].join('')] = voice[4] });
      return {voices: v, score: score}; }

header = "\\header" space* dict

dict = "{" space* (keyword space* "=" space* keyvalue space*)* "}"

keyword = word:[a-zA-Z]+ { return word; }
keyvalue
  = str:str { return str; }
  / "\\markup" space* markup

markup = "{" space* (markupExpr space*)* "}"
markupExpr
  = markup
  / "\\" keyword:([a-zA-Z\-]+)
  / "#'(" space* keyword:([a-zA-Z\-]+) space* "." space* num:("-"?[0-9]+("."[0-9]+)?) space* ")"
  / "#" num:("-"?[0-9]+("."[0-9]+)?)
  / "#" str:str
  / "#(" (space* [a-zA-Z\-:]+ / space* [0-9]+)* ")"
  / text:([^\"\'\{\}\\\#' '\t\r\n]+) // XXX: find what characters are ok

version
  = "\\version" space+ version:str { return version; }

voice
  = "\\relative" space+ n:notePitch space* "{" space*
    measures:(measure space*)+ ("\\bar" space* str space*)? "}" {
      var result = {};
      result.measures = measures.map(function(m) { return m[0] });
      result.relative = n;
      return result;
    }

measure = notes:notegroup space* "|" space* n:measureNum {
  return {measure: n, notes: notes} }

notegroup
  = groups:(space* n:(note / rest / chord) { return [n] }
      / space* [\.!~]  { return [] } // ???
      / space* "\\clef" space* clef:str { return [{clef: clef}] }
      / space* noteCommands { return [] }
      / "\\arpeggio_" { return [] }
      / "\\fermata" { return [] }
      / "[" space* notes:notegroup space* "]" {
          // previous note has start of beam
          notes.slice(0, notes.length-1).forEach(function(n) {
            n.beam = "continue";
          });
          notes[notes.length-1].beam = "end";
          return notes;
        }
      )* {
        if (groups) {
          var notes = [];
          groups.forEach(function(g) {
            if (notes.length && g.length
                && (g[0].beam == "continue" || g[0].beam == "end")) {
              // Beam starts on previous note
              notes[notes.length-1].beam = "start";
            }
            notes = notes.concat(g)
          });
          return notes;
        }
      }

measureNum = "%" space* n:[0-9]+ { return parseInt(n.join('')) }

noteAcc = "es"+ / "is"+
noteOctave = plus:("'"+) { return new Array(plus.length+1).join("'") } / minus:(","+) { return new Array(minus.length+1).join(",") }
notePitch = pitch:[a-g] acc:noteAcc? octave:noteOctave? forceAcc:([!?]?) {
  return pitch + acc + octave + forceAcc
}

noteDuration = d:[0-9]+ { return parseInt(d.join('')) }

noteCommands = "^" ("\\" [a-zA-Z]+)+

note = p:notePitch d:noteDuration? noteCommands? {
  return {keys: [p], duration: d} }

rest = "r" d:noteDuration? noteCommands? { return {type: "rest", duration: d} }
     / n:note "^\\rest" { n.type = "rest"; return n; }

chord = "<" space* keys:(notePitch space*)+ ">" d:noteDuration? noteCommands? {
  return {keys: keys.map(function(l) { return l[0] }), duration: d} }

score
  = "\\score" space* "{"
    (space* "\\context" space+ [^ \t\r\n]+ space+ dumbMarkup
     / space* "\\" [a-zA-Z\-]+ space+ markup)*
    space* "}" { return { staves: [["voiceone"], ["voicetwo"]] } } // FIXME

str = "\"" str:([^"]+) "\"" { return str.join(""); }
space = [' '\t\r\n]

dumbMarkup = "<<" ([^<>]+ / dumbMarkup)* ">>"
