{
  var variables = {}; // Store all variables defined while parsing
}

start
  = space? exprs:(
      "\\version" space? version:str space? { return {} }
    / header space? { return {} }
    / k:keyword space? "=" space? m:(musicStaff / musicVoice / musicBlock) space? {
        variables[k] = m;
        return {};
      }
    / ("\\score" space?)? m:musicStaff space? { return { score: m } }
  )+ {
    var score = null;
    exprs.forEach(function(e) {
      if (e.score) {
        if (score) {
          throw new Vex.RERR("InvalidLilyPond",
                  "Multiple scores not supported");
        }
        score = e.score;
      }
    });
    return score;
  }

header = "\\header" space? dict

dict = "{" space? (keyword space? "=" space? keyvalue space?)* "}"

keyword = word:([a-zA-Z])+ { return word.join(''); }
keyvalue
  = str:str { return str; }
  / "\\markup" space? markup

markup = "{" space? (markupExpr space?)* "}"
markupExpr /* Allow arbitrary characters with nesting braces */
  = markup
  / text:([^{}]+)

musicStaff // LilyPond Staff, created explicitly or implicitly
  = "\\" ("new" / "context") space "Staff" space v:musicVoice
    { return {type: "stave", voices: [v]} }

musicVoice // LilyPond Voice, created explicitly or implicitly
  = "\\" ("new" / "context") space "Voice" space m:musicBlock
    { // Voice is just an array of arrays (measures) with an extra property
      // type: "voice"
      m.type = "voice";
      return m; }
  / m:musicBlock {
      m.type = "voice";
      return m;
    }

musicBlock 
  = // Music delimited by braces, possibly with multiple Staves/Voices
    "{" space? m:musicExpr space? "}" { return m }
  / "\\relative" space n:notePitch space m:musicBlock {
    m.relative = n;
    return m; }
  // Interpolated variable; must have been defined previously
  / "\\" variable:([A-z]+) {
    variable = variable.join('');
    if (! (variable in variables))
      return null; // Don't match
      //throw new Vex.RERR("InvalidLilyPond",
                         //"Variable not defined: '" + variable + "'");
    return variables[variable]; } // TODO: deep copy variable
    // Simultaneous contexts
  / "<<" space? blocks:(musicBlock space?)+ ">>" {
    return blocks.map(function(l){return l[0]}) }

musicExpr // Split music into multiple measures
  = space? measures:(notes space? measureSep space?)*
           lastMeasure:notes space? {
      //return {measures:
              //measures.map(function(l){return l[0]}).concat([lastMeasure])};
              return(measures.map(function(l){return l[0]}).concat([lastMeasure]));
              //return [lastMeasure];
    }
measureSep = "|"

notes // Notes/commands in a single measure
  = groups:(
        n:(note / rest / chord) space? { return [n] }
      / [\.!~] space? { return [] } // ???
      / "\\clef" space? clef:str space? { return [{clef: clef}] }
      / noteCommands space? { return [] }
      / "\\bar" space? "\"" [^"]+ "\"" space? { return [] }
      / "\\" [A-z_]+ space? { return [] }
      / "[" space? notes:notes space? "]" space? {
          // previous note has start of beam
          notes.slice(0, notes.length-1).forEach(function(n) {
            n.beam = "continue";
          });
          notes[notes.length-1].beam = "end";
          return notes;
        }
      / "(" space? notes:notes space? ")" space? {
          // TODO: slur
          return notes;
        }
      )* {
        if (groups) {
          var notes = [];
          groups.forEach(function(g) {
            if (notes.length && g.length
                && (g[0].beam == "continue" || g[0].beam == "end")) {
              // Beam starts on previous note
              notes[notes.length-1].beam = "start";
            }
            notes = notes.concat(g)
          });
          return notes;
        }
      }

noteAcc = flat:"es"+ { return new Array(flat.length+1).join('b') }
        / sharp:"is"+{ return new Array(sharp.length+1).join('#') }
noteOctave = plus:("'"+) { return new Array(plus.length+1).join("'") } / minus:(","+) { return new Array(minus.length+1).join(",") }
notePitch
  = acc:noteAcc octave:noteOctave? forceAcc:([!?]?) {
      // Allow missing pitch where previous pitch is used implicitly
      return acc + octave + forceAcc
    }
  / pitch:[a-g] acc:noteAcc? octave:noteOctave? forceAcc:([!?]?) {
      return pitch + acc + octave + forceAcc
    }

noteDuration = d:[0-9]+ dots:([\.]+)? { return(d.join('') + new Array(dots.length+1).join('d')) }

noteCommands = "^" (space? "\\" [a-zA-Z]+)+

note = p:notePitch d:noteDuration? noteCommands? {
  return {keys: [p], duration: d} }

rest = type:[rs] d:noteDuration? noteCommands? {
          return {type: "rest", duration: d, hidden: (type == "s")} }
     / n:note "^\\rest" { n.type = "rest"; return n; }

chord = "<" space? keys:(notePitch space?)+ ">" d:noteDuration? noteCommands? {
  return {keys: keys.map(function(l) { return l[0] }), duration: d} }



str = "\"" str:([^"]+) "\"" { return str.join(""); }
space
  = ([ \t\r\n]
  / "%" [^\r\n]+ ("\r\n" / "\n" / "\r") // Single-line comment
  / "%{" [^%]* "%}" // Multi-line comment
  )+
